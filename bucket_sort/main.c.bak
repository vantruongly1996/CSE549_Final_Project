#include <bsg_manycore_tile.h>
#include <bsg_manycore_errno.h>
#include <bsg_manycore_tile.h>
#include <bsg_manycore_loader.h>
#include <bsg_manycore_cuda.h>
#include <math.h>
#include <complex.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <stdio.h>
#include <bsg_manycore_regression.h>

#define ALLOC_NAME "default_allocator"

int kernel_IS(int argc, char **argv) {
    int rc;
    char *bin_path, *test_name;
    struct arguments_path args = {NULL, NULL};
  
    argp_parse(&argp_path, argc, argv, 0, 0, &args);
    bin_path = args.path;
    test_name = args.name;

    bsg_pr_test_info("Running kernel_IS.\n");
    srand(time(NULL));

    // Initialize Device
    hb_mc_device_t device;
    BSG_CUDA_CALL(hb_mc_device_init(&device, test_name, 0));

   
   
    // Iterate over pods
    hb_mc_pod_id_t pod;
    hb_mc_device_foreach_pod_id(&device, pod) {
        bsg_pr_info("Loading program for pod %d\n.", pod);
        BSG_CUDA_CALL(hb_mc_device_set_default_pod(&device, pod));
        BSG_CUDA_CALL(hb_mc_device_program_init(&device, bin_path, ALLOC_NAME, 0));

        // Allocate Memory
        int *arr_host = (int*) malloc(sizeof(int) * SIZE);
        int *arr_device;
	//int * arr_expected_host = (int*) malloc(sizeof(int)*SIZE);
        //BSG_CUDA_CALL(hb_mc_device_malloc(&device, SIZE * sizeof(int), &arr_device));

        // Initialize array with random integers
        for (int i = 0; i < SIZE; ++i) {
            arr_host[i] = rand() % 100;  // Random integers from 0 to 99

         //C_expected_host[i] = A_host[i] + B_host[i];
	}

        // Copy array to device
        BSG_CUDA_CALL(hb_mc_device_memcpy(&device, arr_device, arr_host, SIZE * sizeof(int), HB_MC_MEMCPY_TO_DEVICE));

        // Enqueue Kernel
        hb_mc_dimension_t tg_dim = { .x = 1, .y = 1 };
        hb_mc_dimension_t grid_dim = { .x = 1, .y = 1 };
        #define CUDA_ARGC 2
        uint32_t cuda_argv[CUDA_ARGC] = { arr_device, SIZE };

        // Enqueue Kernel
        BSG_CUDA_CALL(hb_mc_kernel_enqueue(&device, grid_dim, tg_dim, "kernel_IS", CUDA_ARGC, cuda_argv));

        // Launch kernel
        BSG_CUDA_CALL(hb_mc_device_tile_groups_execute(&device));

        // Copy result back to host
        BSG_CUDA_CALL(hb_mc_device_memcpy(&device, arr_host, arr_device, SIZE * sizeof(int), HB_MC_MEMCPY_TO_HOST));

        // Validate sorted array
        int sorted = 1;
        for (int i = 0; i < SIZE - 1; ++i) {
            if (arr_host[i] > arr_host[i + 1]) {
                sorted = 0;
                break;
            }
        }

        if (sorted) {
            bsg_pr_info("Array successfully sorted.\n");
        } else {
            bsg_pr_err("Array not sorted.\n");
            return HB_MC_FAIL;
        }

        // Cleanup
        BSG_CUDA_CALL(hb_mc_device_finish(&device));
        free(arr_host);
    }

    return HB_MC_SUCCESS;
}

declare_program_main("kernel_IS", kernel_IS);

